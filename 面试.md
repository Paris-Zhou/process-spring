------

# Java 面试题500道大全

## 一、Java 基础

### 1. JDK 和 JRE 的区别？

- **JDK (Java Development Kit)**：包含 JRE 和开发工具，如 javac 编译器。
- **JRE (Java Runtime Environment)**：只包含 JVM 和 Java 基础库，仅用于运行 Java 程序。

### 2. Java 语言的特点？

- **面向对象**：支持封装、继承、多态。
- **跨平台**：依赖 JVM，支持“一次编写，到处运行”。
- **自动内存管理**：GC 机制自动释放不再使用的对象。
- **多线程**：支持并发编程，提供 `Thread`、`Runnable`、`ExecutorService` 等。
- **安全性**：提供类加载器、字节码校验、安全管理机制。

### 3. 基本数据类型有哪些？各占多少字节？

| 类型    | 字节 | 范围                 |
| ------- | ---- | -------------------- |
| byte    | 1    | -128 到 127          |
| short   | 2    | -32,768 到 32,767    |
| int     | 4    | -2^31 到 2^31-1      |
| long    | 8    | -2^63 到 2^63-1      |
| float   | 4    | 3.4e-038 到 3.4e+038 |
| double  | 8    | 1.7e-308 到 1.7e+308 |
| char    | 2    | 0 到 65535           |
| boolean | 1    | true / false         |

### 4. `String` 、 `StringBuffer` 和 `StringBuilder` 的区别？

- `String`：不可变字符串，每次修改都会创建新对象。
- `StringBuffer`：线程安全，可变字符串，采用 `synchronized` 进行同步。
- `StringBuilder`：非线程安全，但单线程下性能更高。

### 5. `equals` 和 `==` 的区别？

- `==` 用于比较内存地址，基本数据类型比较值。
- `equals`：默认也是比较内存地址，但 `String` 和某些类重写后是比较内容。

### 6. `hashCode` 的作用？为什么要重写 `hashCode`？

- `hashCode` 返回对象的哈希值，常用于 HashMap、HashSet 等集合。
- 需要与 `equals` 保持一致性，否则在 Hash 结构中无法正确查找元素。

### 7. `final`、`finally` 和 `finalize` 的区别？

- `final`：修饰类（不可继承）、方法（不可重写）、变量（不可修改）。
- `finally`：异常处理中的 `try-finally` 语句块，确保代码执行。
- `finalize`：对象被 GC 回收前调用的方法，通常不建议使用。

### 8. Java 的四种引用类型（强、软、弱、虚引用）？

- **强引用**：默认引用方式，不会被 GC 回收。
- **软引用** (`SoftReference`)：内存不足时回收，适用于缓存。
- **弱引用** (`WeakReference`)：GC 发现即回收，适用于弱缓存。
- **虚引用** (`PhantomReference`)：对象被回收前触发回调，管理直接内存。

### 9. `ArrayList` 和 `LinkedList` 的区别？

- `ArrayList`：基于动态数组，查询快 (`O(1)`)，增删慢 (`O(n)`)。
- `LinkedList`：基于双向链表，查询慢 (`O(n)`)，增删快 (`O(1)`)。

### 10. `HashMap` 和 `ConcurrentHashMap` 的区别？

- `HashMap`：线程不安全，JDK 1.8 采用数组 + 链表 + 红黑树。
- `ConcurrentHashMap`：线程安全，采用分段锁（JDK 1.7）或 CAS + Synchronized（JDK 1.8）。

### 11. `HashMap` 的底层实现？

- **JDK 1.7**：数组 + 链表，头插法（易形成死循环）。
- **JDK 1.8**：数组 + 链表 + 红黑树，尾插法，优化扩容性能。

### 12. `TreeMap`、`LinkedHashMap` 和 `HashMap` 的区别？

- `HashMap`：无序，基于哈希表。
- `LinkedHashMap`：有序，基于双向链表，维护插入顺序。
- `TreeMap`：有序，基于红黑树，按 key 进行排序。

### 13. `HashSet` 和 `TreeSet` 的区别？

- `HashSet`：基于 `HashMap`，无序。
- `TreeSet`：基于 `TreeMap`，自动排序。

### 14. `ArrayList` 扩容机制？

- 默认初始容量 10，每次扩容 1.5 倍。
- 复制旧数组内容到新数组。

### 15. Java 序列化的方式有哪些？

- `Serializable`：默认 Java 序列化。
- `Externalizable`：自定义序列化方式，提高性能。
- `JSON` / `XML` 序列化：使用 Jackson、Gson。

### 16. `Cloneable` 接口的作用？深拷贝和浅拷贝的区别？

- `Cloneable`：支持对象克隆，`Object.clone()` 方法。
- **浅拷贝**：仅复制基本类型，引用类型仍指向原对象。
- **深拷贝**：完全复制对象，包括引用对象。

### 17. `Comparable` 和 `Comparator` 的区别？

- `Comparable`：实现 `compareTo()`，定义对象默认排序。
- `Comparator`：实现 `compare()`，用于自定义排序。

### 18. Java 的异常分类？Checked 和 Unchecked 异常的区别？

- **Checked Exception**：编译期异常，必须处理，如 `IOException`。
- **Unchecked Exception**：运行时异常，如 `NullPointerException`。

### 19. Java 反射的基本使用？性能问题如何优化？

- **使用** `**Class.forName()**`**、**`**getDeclaredMethod()**`**、**`**invoke()**` **进行反射调用。**
- **性能优化**：
  - 预缓存 Method 对象。
  - 使用 `MethodHandle`（JDK 7+）。
  - 使用 `Unsafe`（非官方推荐）。

### 20. `ThreadLocal` 的实现原理？有哪些应用场景？

- **每个线程持有一个独立变量副本，避免线程共享变量冲突。**
- **应用场景**：
  - 事务管理（如 Spring `@Transactional`）。
  - 用户 Session 变量。
  - 连接池、线程池。

## **二、JVM & GC**

### **1. JVM 运行时数据区的组成？**

JVM 运行时数据区主要包括：

- **程序计数器（PC Register）**：记录当前线程执行的字节码指令地址。
- **Java 虚拟机栈（JVM Stack）**：存储局部变量表、操作数栈、方法出口等，每个线程私有。
- **本地方法栈（Native Method Stack）**：为 Native 方法服务，类似 JVM 栈。
- **堆（Heap）**：存放对象实例，Java GC 主要管理的区域，线程共享。
- **方法区（Method Area）**（包含运行时常量池）：存储类元信息、常量、静态变量等，线程共享。

### **2. JVM 内存模型（Java Memory Model, JMM）？**

JMM 规定了 **多线程之间可见性、有序性、原子性** 的规范，主要特性：

- **主内存（Main Memory）**：所有线程共享变量存放的地方。
- **工作内存（Working Memory）**：线程各自的缓存，操作必须先拷贝到工作内存再修改。
- **Happens-Before 规则**：包括 **volatile 规则、synchronized 规则、传递性** 等，保证可见性和有序性。

### **3. 类加载过程？类加载器有哪些？**

**类加载过程：**

1. **加载（Loading）**：读取字节码，创建 Class 对象。
2. **验证（Verification）**：检查字节码合法性。
3. **准备（Preparation）**：为静态变量分配内存，赋默认值。
4. **解析（Resolution）**：将符号引用解析为直接引用。
5. **初始化（Initialization）**：执行静态代码块，赋初始值。

**类加载器：**

- **Bootstrap ClassLoader**（引导类加载器）：加载 `java.lang` 核心类。
- **ExtClassLoader**（扩展类加载器）：加载 `ext` 目录下的类。
- **AppClassLoader**（应用类加载器）：加载 `classpath` 下的类。
- **自定义类加载器**

### **4. `volatile` 关键字的实现原理？**

- **可见性**：`volatile` 变量修改后，其他线程立即可见，底层使用 **内存屏障（Memory Barrier）** 实现。
- **禁止指令重排序**：利用 **`lock` 前缀的 CPU 指令**，保证代码执行顺序。

### **5. `synchronized` 的实现原理？**

- **JVM 实现**：通过对象头的 **Mark Word** 和 **Monitor（监视器锁）** 实现。
- **锁的升级**：无锁 → 偏向锁 → 轻量级锁 → 重量级锁。

### **6. `synchronized` 和 `Lock` 的区别？**

| 特性             | `synchronized` | `Lock` |
| ---------------- | -------------- | ------ |
| 锁的粒度         | 对象/类        | 代码块 |
| 是否可中断       | 否             | 是     |
| 是否可公平       | 否             | 可选   |
| 是否支持超时     | 否             | 是     |
| 是否可尝试获取锁 | 否             | 是     |

### **7. `CAS`（Compare And Swap）是什么？如何避免 ABA 问题？**

- **CAS** 是无锁并发的核心机制，比较当前值与期望值，若相等则更新。
- **ABA 问题** 解决方案：使用 **`AtomicStampedReference`** 记录版本号。

### **8. Java 对象的创建过程？**

1. **类加载检查**（类是否已加载）。
2. **分配内存**（堆中分配，TLAB 加速）。
3. **初始化零值**。
4. **设置对象头**（Mark Word、Class Pointer）。
5. **调用构造方法**。

### **9. GC（垃圾回收）的算法有哪些？**

- **引用计数法**（容易产生循环引用，已淘汰）。
- **可达性分析（GC Roots）**。
- **标记-清除（Mark-Sweep）**。
- **标记-整理（Mark-Compact）**。
- **复制（Copying）**。
- **分代回收（Generation GC）**。

### **10. Java 中的垃圾回收器有哪些？CMS 和 G1 的区别？**

- **Serial、Parallel、CMS、G1、ZGC、Shenandoah**。
- **CMS（并发标记清除）**：低延迟，但碎片多，STW 时间不可控。
- **G1（垃圾优先回收）**：按区域回收，减少碎片，支持预测性 GC。

### **11. 如何判断对象是否可回收（可达性分析）？**

- **GC Roots 追踪法**：GC Roots 不可达即回收。

- GC Roots 包括

  ：

  - JVM 栈中的引用
  - 方法区静态变量
  - 本地方法栈 JNI 引用

### **12. `OOM` 常见的几种类型？**

- **`java.lang.OutOfMemoryError: Java heap space`**（堆溢出）。
- **`java.lang.OutOfMemoryError: Metaspace`**（元空间溢出）。
- **`java.lang.OutOfMemoryError: GC overhead limit exceeded`**（GC 过载）。
- **`java.lang.OutOfMemoryError: Direct buffer memory`**（NIO 堆外内存溢出）。

### **13. `Full GC` 和 `Minor GC` 的区别？**

- **Minor GC**：回收年轻代，频率高，耗时短。
- **Full GC**：回收整个堆（包括老年代），频率低，耗时长。

### **14. `Stop The World` 现象？**

GC 时所有线程暂停执行，影响系统响应。

### **15. `Metaspace` 和 `PermGen` 的区别？**

- **Metaspace（JDK 8 及以上）**：用 **本地内存** 取代 **永久代**。
- **PermGen（JDK 7 及以下）**：受堆大小限制，容易 `OOM`。

### **16. `TLAB`（线程本地分配缓存）是什么？**

线程私有的小对象分配区，避免锁争用，提高分配效率。

### **17. `Escape Analysis`（逃逸分析）是什么？**

分析对象是否逃离方法作用域，决定是否在栈上分配。

### **18. `GC Root` 有哪些？**

- 栈中的本地变量
- 方法区的静态变量
- JNI 引用的对象
- 活跃的线程

### **19. `SoftReference` 和 `WeakReference` 的区别？**

- **`SoftReference`（软引用）**：内存不足时回收，适用于缓存。
- **`WeakReference`（弱引用）**：下一次 GC 就会回收。

### **20. JVM 调优的常见参数？如何优化 Full GC？**

- 常见参数

  ：

  - `-Xms` / `-Xmx`（堆大小）。
  - `-XX:+UseG1GC`（使用 G1 GC）。
  - `-XX:MetaspaceSize`（元空间大小）。

- 优化 Full GC

  ：

  - 增加堆大小，减少 Full GC 触发频率。
  - 选择合适的 GC 策略（如 G1）。
  - 调整 `MaxMetaspaceSize` 避免元空间溢出。

------

## **三、多线程 & 并发**

### **1. 线程的生命周期？**

线程的生命周期包括以下几个状态：

- **新建（New）**：线程创建后，尚未启动。
- **就绪（Runnable）**：线程可以开始执行，但尚未获得 CPU 时间片。
- **运行中（Running）**：线程正在执行。
- **阻塞（Blocked）**：线程因某种原因（如 I/O 操作）进入阻塞状态。
- **等待（Waiting）**：线程进入等待状态，等待其他线程通知。
- **超时等待（Timed Waiting）**：线程等待特定时间后自动恢复执行。
- **终止（Terminated）**：线程执行完成或被终止。

### **2. `Runnable` 和 `Callable` 的区别？**

- **`Runnable`**：无返回值，`run()` 方法内执行任务。
- **`Callable`**：有返回值，`call()` 方法内执行任务，并能抛出异常。
- **`Future`**：`Runnable` 使用 `Thread` 启动，`Callable` 使用 `ExecutorService` 启动，返回 `Future` 对象，支持获取结果和处理异常。

### **3. `FutureTask` 的原理？**

- **`FutureTask`** 是 `Runnable` 和 `Callable` 的实现类，它实现了 `Runnable` 和 `Future` 接口。
- 用来包装一个 `Callable` 任务，可以通过 `FutureTask.get()` 获取任务执行结果，并且支持任务取消。
- 它通过 `AtomicReference` 实现任务状态的更新，保证线程安全。

### **4. `ThreadPoolExecutor` 的参数含义？**

- **corePoolSize**：核心线程池大小。
- **maximumPoolSize**：最大线程池大小。
- **keepAliveTime**：线程空闲时的存活时间。
- **unit**：时间单位。
- **workQueue**：任务队列，用于存放待执行的任务。
- **threadFactory**：线程工厂，用于创建线程。
- **handler**：拒绝策略，当线程池和队列都满时，如何处理新提交的任务。

### **5. 线程池的拒绝策略？**

- **AbortPolicy**：抛出 `RejectedExecutionException`。
- **CallerRunsPolicy**：由调用者线程处理任务。
- **DiscardPolicy**：丢弃任务，不抛异常。
- **DiscardOldestPolicy**：丢弃队列中最旧的任务。

### **6. `BlockingQueue` 有哪些实现？**

- **ArrayBlockingQueue**：有界阻塞队列，基于数组实现。
- **LinkedBlockingQueue**：有界/无界阻塞队列，基于链表实现。
- **PriorityBlockingQueue**：无界阻塞队列，元素按优先级顺序排列。
- **DelayQueue**：基于时间延迟的阻塞队列，元素在指定时间到期时才能被取出。
- **SynchronousQueue**：无缓冲阻塞队列，每个插入操作必须等待一个移除操作。

### **7. `CountDownLatch` 和 `CyclicBarrier` 的区别？**

- **`CountDownLatch`**：线程在等待计数器为 0 时才会继续，计数器只能减到 0，不能重用。
- **`CyclicBarrier`**：多个线程在屏障点等待，直到所有线程到达屏障点才会继续，计数器可以重置，适合用于循环任务。

### **8. `Semaphore` 的作用？**

- **`Semaphore`** 控制同时访问共享资源的线程数。
- 通过计数信号量来限制资源的数量，当信号量为 0 时，线程必须等待。

### **9. `ReentrantLock` 和 `synchronized` 的区别？**

- `ReentrantLock`

  ：

  - 可中断、可重入。
  - 可实现公平锁和非公平锁。
  - 支持 `tryLock()` 尝试获取锁，避免死锁。
  - 支持显式释放锁（`unlock()`）。

- `synchronized`

  ：

  - 自动加锁和释放锁。
  - 无法设置超时、无法中断。

### **10. `Condition` 的作用？**

- `Condition` 是与 `ReentrantLock` 配合使用的线程同步工具，支持线程间的等待和通知机制。
- 提供 `await()`, `signal()`, `signalAll()` 方法，替代 `Object.wait()` 和 `Object.notify()`。

### **11. `ThreadLocal` 的使用场景？**

- **`ThreadLocal`** 提供线程私有变量，用于线程之间的数据隔离。
- 适用于：
  - 每个线程需要独立的数据副本（如数据库连接、用户会话等）。
  - 避免多线程间共享数据冲突。

### **12. `AQS`（AbstractQueuedSynchronizer）是什么？**

- **AQS** 是一个抽象类，提供了构建锁和同步器的基础框架，内部使用一个 FIFO 等待队列来管理线程的阻塞和唤醒。
- 常见的实现包括 `ReentrantLock`, `CountDownLatch`, `Semaphore` 等。

### **13. `volatile` 关键字能保证原子性吗？**

- **`volatile`** 关键字保证了变量的可见性，但不保证原子性。
- 对于复合操作（如 `i++`），需要额外的同步机制保证原子性。

### **14. `ABA` 问题是什么？如何解决？**

- **ABA 问题**：线程在执行 CAS 操作时，发现值从 A 变为 B，又变回 A，但实际可能已经有别的线程修改过该值。
- **解决方法**：使用带有版本号的原子引用类，如 `AtomicStampedReference`。

### **15. `CopyOnWriteArrayList` 的底层原理？**

- 采用 **写时复制（Copy on Write）** 的策略，当修改时（如 `add`, `remove`）会创建副本，操作副本后再替换原列表。
- 适用于读多写少的场景，保证了高效的并发读。

### **16. `ConcurrentHashMap` 的分段锁机制？**

- **分段锁（Segment Locking）**：将 `ConcurrentHashMap` 分为多个段，每个段有独立的锁，保证在不同段上的并发操作不会互相影响。
- JDK 8 后，使用了 **桶级别的锁**（锁分段）。

### **17. `CAS` 的实现原理？**

- **CAS**（Compare and Swap）是通过硬件支持的原子操作，比较内存中的值和预期值，如果相等则交换值，否则不操作。
- 通过原子性来保证并发环境下的线程安全。

### **18. `Atomic` 包下的常见类？**

- **`AtomicInteger`**：原子整数操作。
- **`AtomicLong`**：原子长整型操作。
- **`AtomicReference`**：原子引用操作。
- **`AtomicBoolean`**：原子布尔值操作。
- **`AtomicStampedReference`**：原子带时间戳的引用，解决 ABA 问题。

### **19. `Fork/Join` 框架的使用？**

- **`Fork/Join`** 框架用于分治并行任务的执行。
- 任务被分成若干个子任务，子任务并行执行，最后合并结果。
- **`ForkJoinPool`** 提供了高效的线程池管理，利用工作窃取算法实现负载均衡。

### **20. 并行流（ParallelStream）和串行流（Stream）的区别？**

- **串行流**：顺序执行流操作，使用一个线程。
- **并行流**：通过多个线程并行执行流操作，利用多核 CPU 提升性能，适用于计算密集型任务。
- **性能差异**：并行流在处理大量数据时性能更好，但在数据量小或操作开销大时可能导致性能下降。

------

## **四、Spring & Spring Boot**

### **1. Spring 的核心组件有哪些？**

Spring 的核心组件包括：

- **IoC（控制反转，Inversion of Control）**：由 `BeanFactory` 和 `ApplicationContext` 负责，主要用于对象创建、依赖注入和生命周期管理。
- **AOP（面向切面编程，Aspect-Oriented Programming）**：基于 `ProxyFactory` 实现方法拦截，如事务管理、日志记录。
- **事务管理（Transaction Management）**：基于 AOP 实现声明式事务 (`@Transactional`)，底层支持 `DataSourceTransactionManager`、`JpaTransactionManager`。
- **Spring MVC**：基于 `DispatcherServlet` 处理请求，使用 `HandlerMapping`、`HandlerAdapter` 解析 Controller。
- **Spring JDBC & ORM**：提供 `JdbcTemplate`、整合 Hibernate、MyBatis，简化数据库访问。
- **Spring Security**：用于身份认证和权限管理，基于 `SecurityContextHolder` 和 `FilterChainProxy` 实现安全控制。
- **Spring Boot**：提供自动配置、嵌入式 Tomcat、简化 Spring 应用开发。

------

### **2. Spring Bean 的生命周期？**

Spring `Bean` 的生命周期分为以下几个阶段：

### **（1）实例化 Bean**

Spring 通过 `ReflectionUtils.instantiateClass()` 或 `CGLIB` 代理创建 Bean。

### **（2）填充属性**

- 解析 `@Autowired`、`@Value` 注解
- 通过 `BeanPostProcessor` 进行增强

### **（3）初始化前**

- `BeanPostProcessor#postProcessBeforeInitialization()`
- 解析 `@PostConstruct` 进行方法回调

### **（4）初始化**

- `InitializingBean#afterPropertiesSet()`
- `init-method="xxx"` 进行手动配置初始化

### **（5）初始化后**

- `BeanPostProcessor#postProcessAfterInitialization()` 进行 AOP 增强

### **（6）使用 Bean**

### **（7）销毁 Bean**

- `@PreDestroy`
- `DisposableBean#destroy()`
- `destroy-method="xxx"`

完整流程源码示例：

```
java复制编辑@Component
public class MyBean implements InitializingBean, DisposableBean {
    
    @PostConstruct
    public void postConstruct() {
        System.out.println("PostConstruct 执行");
    }

    @Override
    public void afterPropertiesSet() {
        System.out.println("InitializingBean 执行");
    }

    @PreDestroy
    public void preDestroy() {
        System.out.println("PreDestroy 执行");
    }

    @Override
    public void destroy() {
        System.out.println("DisposableBean 执行");
    }
}
```

------

### **3. Spring 依赖注入的几种方式？**

Spring 支持 5 种依赖注入方式：

### **（1）构造函数注入**

```
java复制编辑@Component
public class UserService {
    private final UserRepository userRepository;

    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

适用于**强制依赖**的场景。

------

### **（2）Setter 方法注入**

```
java复制编辑@Component
public class UserService {
    private UserRepository userRepository;

    @Autowired
    public void setUserRepository(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

适用于**可选依赖**的场景。

------

### **（3）字段注入**

```
java复制编辑@Component
public class UserService {
    @Autowired
    private UserRepository userRepository;
}
```

**不推荐**，不利于单元测试。

------

### **（4）`@Resource` 注解（JSR-250 标准）**

```
java复制编辑@Component
public class UserService {
    @Resource(name = "userRepository")
    private UserRepository userRepository;
}
```

按 **Bean 名称** 注入。

------

### **（5）`@Inject` 注解（JSR-330 标准）**

```
java复制编辑@Component
public class UserService {
    @Inject
    private UserRepository userRepository;
}
```

类似 `@Autowired`，但不支持 `required` 属性。

------

### **4. `@Transactional` 注解的实现原理**

### **Spring 事务的底层原理**

- **Spring AOP 代理 `@Transactional` 方法**
- `TransactionInterceptor` 负责拦截方法
- **事务管理器**（`PlatformTransactionManager`）执行事务操作
- `DataSourceTransactionManager` 通过 **数据库连接的 `setAutoCommit(false)` 实现事务**

### **源码分析**

Spring 通过 `TransactionAspectSupport` 处理事务：

```
java复制编辑@Override
public Object invoke(MethodInvocation invocation) throws Throwable {
    return invokeWithinTransaction(invocation.getMethod(), invocation.getThis(),
        invocation::proceed);
}
```

核心方法：

```
java复制编辑protected Object invokeWithinTransaction(Method method, Object target, InvocationCallback invocation)
        throws Throwable {
    TransactionInfo txInfo = createTransactionIfNecessary(transactionManager, txAttr, joinpointIdentification);
    Object result;
    try {
        result = invocation.proceedWithInvocation();
    } catch (Throwable ex) {
        completeTransactionAfterThrowing(txInfo, ex);
        throw ex;
    }
    commitTransactionAfterReturning(txInfo);
    return result;
}
```

> **`createTransactionIfNecessary()` 创建事务** **`commitTransactionAfterReturning()` 提交事务** **`completeTransactionAfterThrowing()` 进行事务回滚**

------

### **5. Spring AOP 的实现原理**

Spring AOP 主要基于 **JDK 动态代理** 和 **CGLIB** 实现。

### **JDK 动态代理（针对接口）**

```
java复制编辑InvocationHandler handler = (proxy, method, args) -> {
    System.out.println("方法调用前");
    Object result = method.invoke(target, args);
    System.out.println("方法调用后");
    return result;
};
MyInterface proxy = (MyInterface) Proxy.newProxyInstance(
    target.getClass().getClassLoader(),
    target.getClass().getInterfaces(),
    handler
);
```

### **CGLIB 代理（针对类）**

```
java复制编辑Enhancer enhancer = new Enhancer();
enhancer.setSuperclass(MyClass.class);
enhancer.setCallback(new MethodInterceptor() {
    @Override
    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
        System.out.println("方法调用前");
        Object result = proxy.invokeSuper(obj, args);
        System.out.println("方法调用后");
        return result;
    }
});
MyClass proxy = (MyClass) enhancer.create();
```

> **Spring AOP 默认使用 JDK 动态代理**，如果类没有实现接口，则使用 CGLIB。

### **6. Spring 的事务传播行为**

Spring 提供了 7 种事务传播方式，通过 `Propagation` 枚举定义：

```
java


复制编辑
@Transactional(propagation = Propagation.REQUIRED)
```

| 传播方式          | 含义                                                         |
| ----------------- | ------------------------------------------------------------ |
| **REQUIRED**      | 默认值，**当前方法必须在一个事务中运行**，如果调用方已有事务，则加入；否则新建事务 |
| **REQUIRES_NEW**  | **无论调用方是否有事务，都会新建事务**，原事务挂起           |
| **SUPPORTS**      | 支持事务，如果调用方有事务，就加入；否则以**非事务方式运行** |
| **NOT_SUPPORTED** | 以**非事务方式运行**，如果调用方有事务，则挂起事务           |
| **MANDATORY**     | **必须在事务中运行**，如果没有事务，则抛出 `TransactionException` |
| **NEVER**         | **必须在无事务环境运行**，如果有事务，则抛出 `TransactionException` |
| **NESTED**        | 在**当前事务内嵌套事务**，可以独立回滚                       |

------

### **7. Spring Boot 的自动配置原理**

Spring Boot 通过 `@EnableAutoConfiguration` 实现自动配置，核心组件：

- **`SpringFactoriesLoader`**：从 `META-INF/spring.factories` 读取 `EnableAutoConfiguration` 配置
- **`@ConditionalOnXxx`** 注解：决定是否启用某个自动配置类
- **`AutoConfigurationImportSelector`** 选择自动配置类

### **源码解析**

Spring Boot 启动时，会扫描 `spring.factories`：

```
java


复制编辑
public static final String FACTORIES_RESOURCE_LOCATION = "META-INF/spring.factories";
```

然后解析自动配置：

```
java复制编辑public String[] selectImports(AnnotationMetadata metadata) {
    return getAutoConfigurationEntry(metadata).toArray(new String[0]);
}
```

最终，Spring Boot 根据 `@ConditionalOnXxx` 规则，决定是否启用某个 Bean。

------

### **8. Spring MVC 的核心组件**

Spring MVC 主要包含 5 大核心组件：

1. **`DispatcherServlet`**：前端控制器，所有请求都经过它
2. **`HandlerMapping`**：根据 URL 查找 `Controller` 处理器
3. **`HandlerAdapter`**：适配 `Controller` 方法
4. **`ViewResolver`**：解析返回的 `View`
5. **`Interceptor`**：拦截请求，可用于权限控制

------

### **9. DispatcherServlet 的工作流程**

Spring MVC 处理请求的大致流程：

1. **用户请求 `DispatcherServlet`**
2. **`HandlerMapping` 找到对应的 `Controller`**
3. **`HandlerAdapter` 调用 `Controller` 方法**
4. **`Controller` 返回 `ModelAndView`**
5. **`ViewResolver` 解析视图**
6. **返回 `View` 进行渲染**
7. **响应结果返回给客户端**

------

### **10. BeanFactory 和 ApplicationContext 的区别**

|                  | `BeanFactory`                   | `ApplicationContext`         |
| ---------------- | ------------------------------- | ---------------------------- |
| **作用**         | 低级容器，提供 Bean 创建        | 高级容器，扩展 `BeanFactory` |
| **是否延迟加载** | **默认延迟加载**，按需创建 Bean | **启动时预加载所有 Bean**    |
| **支持 AOP**     | 不支持                          | **支持**                     |
| **国际化**       | 不支持                          | **支持 `MessageSource`**     |
| **事件机制**     | 不支持                          | **支持事件机制**             |

------

### **11. Spring Security 认证流程**

Spring Security 认证流程如下：

1. **`UsernamePasswordAuthenticationFilter`** 拦截登录请求
2. **`AuthenticationManager`** 进行身份认证
3. **`UserDetailsService`** 读取用户信息
4. **`AuthenticationProvider`** 进行认证
5. **认证成功后，存入 `SecurityContextHolder`**
6. **认证失败，抛出 `AuthenticationException`**

------

### **12. Spring Boot Actuator 监控指标**

Spring Boot Actuator 提供了丰富的监控端点：

- `/actuator/health`：应用健康状况
- `/actuator/metrics`：JVM 和系统指标
- `/actuator/loggers`：日志级别管理
- `/actuator/env`：环境变量信息
- `/actuator/beans`：Spring 容器中的 Bean 信息

------

### **13. Spring Cloud 的组件及作用**

Spring Cloud 组件：

- **Eureka**：注册中心
- **Ribbon**：负载均衡
- **Feign**：HTTP 远程调用
- **Hystrix**：熔断降级
- **Spring Cloud Gateway**：API 网关
- **Config Server**：配置中心
- **Sleuth + Zipkin**：分布式链路追踪

------

### **14. Eureka 和 Consul 的区别**

|                    | **Eureka**       | **Consul**           |
| ------------------ | ---------------- | -------------------- |
| **CAP 理论**       | **AP（高可用）** | **CP（数据一致性）** |
| **健康检查**       | 仅心跳检测       | HTTP/TTL 检查        |
| **KV 存储**        | 不支持           | **支持**             |
| **多数据中心支持** | 不支持           | **支持**             |

------

### **15. Ribbon 负载均衡策略**

Ribbon 负载均衡策略：

- **RoundRobinRule**：轮询（默认）
- **RandomRule**：随机
- **RetryRule**：失败后重试
- **BestAvailableRule**：选择最小负载的实例
- **AvailabilityFilteringRule**：过滤不可用实例

------

### **16. Feign 的底层实现**

Feign 采用 **动态代理 + Ribbon 负载均衡**：

```
T createProxy(Class<T> type) {
    return (T) Proxy.newProxyInstance(
        type.getClassLoader(),
        new Class<?>[]{type},
        new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) {
                return httpClient.executeRequest(url, args);
            }
        }
    );
}
```

------

### **17. Hystrix 的原理**

Hystrix 采用 **熔断 + 线程隔离**：

1. **线程池隔离**：每个请求使用独立线程池，防止阻塞
2. **熔断机制**：当失败率超过阈值，直接返回降级逻辑
3. **降级策略**：提供 `fallbackMethod` 兜底逻辑

------

### **18. Spring Cloud Gateway 和 Zuul 的区别**

|              | Spring Cloud Gateway | Zuul                 |
| ------------ | -------------------- | -------------------- |
| **底层实现** | **Netty + WebFlux**  | **Servlet + Tomcat** |
| **性能**     | 高吞吐量             | 适合小流量           |
| **异步支持** | **支持**             | **不支持**           |

------

### **19. Seata 的 AT、TCC、Saga 模式**

|              | **AT 模式**          | **TCC 模式**       | **Saga 模式**  |
| ------------ | -------------------- | ------------------ | -------------- |
| **原理**     | 通过回滚日志进行补偿 | Try-Confirm-Cancel | 业务长事务     |
| **适用场景** | 关系型数据库         | 需要手写事务补偿   | 适合跨服务事务 |

------

### **20. Spring Boot 如何集成 Kafka**

Spring Boot 通过 `spring-kafka` 轻松集成 Kafka：

```JAVA
yaml复制编辑spring:
  kafka:
    bootstrap-servers: localhost:9092
    consumer:
      group-id: myGroup
    producer:
      retries: 3
java复制编辑@KafkaListener(topics = "myTopic", groupId = "myGroup")
public void listen(String message) {
    System.out.println("Received: " + message);
}
```

------

## **五、数据库 & SQL 优化**

1. `MySQL` 的存储引擎有哪些？区别？
2. `B+树` 索引的原理？
3. `覆盖索引`、`最左匹配原则`？
4. `MySQL` 索引优化有哪些？
5. `explain` 的结果如何分析？
6. `MVCC`（多版本并发控制）是什么？
7. `InnoDB` 和 `MyISAM` 的区别？
8. `MySQL` 的事务隔离级别？
9. `死锁` 是如何产生的？如何解决？
10. `Redis` 数据结构有哪些？
11. `Redis` 如何持久化数据？
12. `Redis` 缓存穿透、缓存雪崩、缓存击穿？
13. `ClickHouse` 如何存储数据？
14. `MongoDB` 和 `MySQL` 的区别？
15. `InfluxDB` 在时序数据存储上的优势？
16. `TDengine` 如何优化查询效率？
17. `Elasticsearch` 的索引分片策略？
18. `SQL` 如何优化 `group by` 查询？
19. `PostgreSQL` 的优缺点？
20. `ShardingSphere` 的分库分表原理？

------

## **六、分布式 & 微服务**

1. `CAP` 定理是什么？
2. `BASE` 理论是什么？
3. `Raft` 和 `Paxos` 的区别？
4. `分布式锁` 如何实现？
5. `ZooKeeper` 的原理？
6. `Kafka` 的高可用架构？
7. `RocketMQ` 和 `Kafka` 的区别？
8. `Dubbo` 的核心组件？
9. `gRPC` 和 `RESTful API` 的区别？
10. `JWT` 认证如何防止篡改？
11. `OAuth 2.0` 认证流程？
12. `SAGA` 事务补偿机制？
13. `Redis` 如何实现 `分布式 Session`？
14. `ElasticSearch` 如何设计高可用集群？
15. `Kafka` 如何保证消息顺序？
16. `Kafka` 的 `ISR` 和 `OSR` 机制？
17. `MQ` 如何防止消息丢失？
18. `如何设计一个 100 万 QPS 的系统？`
19. `如何保证高并发下的数据一致性？`
20. `限流、熔断、降级的区别？`